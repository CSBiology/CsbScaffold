<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Stats</name></assembly>
<members>
<member name="T:FSharp.Stats.Complex">
<summary>
Complex number in cartesian form
</summary>
</member>
<member name="T:FSharp.Stats.OpsData`1">
<summary>
 The value stored for the dictionary of numeric operations. If none is present then this indicates
 no operations are known for this type.
</summary>
</member>
<member name="T:FSharp.Stats.complex">
<summary>
Complex number            
</summary>
</member>
<member name="T:FSharp.Stats.Algebra.ILinearAlgebra">
<summary>
This is an internal interface and not for user usage.
It exposes a specialised subset of BLAS/LAPACK functionality.
This functionality is used by us to build the exposed APIs.
It is those exposed APIs that should be used.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.QR(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[m,n] finds Q[m,m] and R[k,n] where k = min m n.
 Have A = Q.R  when m&lt;=n.
 Have A = Q.RX when m&gt;n and RX[m,n] is R[n,n] row extended with (m-n) zero rows.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.LU(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] real matrix.
 Finds P,L,U such that L*U = P*A with L,U lower/upper triangular.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.Cholesky(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] real symmetric positive definite.
 Finds the cholesky decomposition L such that L&apos; * L = A.
 May fail if not positive definite.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.LeastSquares(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Given A[m,n] and B[m] solves AX = B for X[n].
 When m=&gt;n, have over constrained system, finds least squares solution for X.
 When m&lt;n, have under constrained system, finds least norm solution for X.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.Inverse(FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,n] find it&apos;s inverse.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenSpectrumWhenSymmetric``2(``0)">
<summary>
 Compute eigenvalues and eigenvectors for a real symmetric matrix.
 Returns arrays of the values and vectors (both based on reals).
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenValuesWhenSymmetric``2(``0)">
<summary>
 Compute eigenvalues for a real symmetric matrix.
 Returns array of real eigenvalues.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenValues``2(``0)">
<summary>
 Compute eigenvalues of a square real matrix.
 Returns arrays containing the eigenvalues which may be complex.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.EigenSpectrum``2(``0)">
<summary>
 Compute eigenvalue/eigenvector decomposition of a square real matrix.
 Returns two arrays containing the eigenvalues and eigenvectors, which may be complex.
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.preDivideByMatrix(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
 Given A[n,m] and B[n,k] solve for X[m,k] such that AX = B
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebra.preDivideByVector(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Given A[n,m] and B[n] solve for x[m] such that Ax = B
 This call may fail.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.HouseholderTransform(FSharp.Stats.Matrix{System.Double},System.Int32)">
<summary>
 This method computes and performs a Householder reflection. It will change the
 input matrix and return the reflection vector.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.sign(System.Double)">
<summary>
 Computes the sign of a floating point number.
</summary>
</member>
<member name="M:FSharp.Stats.Algebra.LinearAlgebraManaged.unitV(System.Int32)">
<summary>
 Generates a unit vector [1 0 .. 0 ].
</summary>
</member>
<member name="T:FSharp.Stats.Algebra.LinearAlgebraManaged">
<summary>
 This module is for internal use only.
</summary>
</member>
<member name="M:FSharp.Stats.Array.seqInit(System.Double,System.Double,System.Int32)">
<summary>
 Generates array sequence (like R! seq.int)
</summary>
</member>
<member name="M:FSharp.Stats.Array.sampleWithOutReplacement``1(System.Random,``0[],System.Int32)">
<summary>
 Samples from an array of obj without replacement (without putting back)
</summary>
</member>
<member name="M:FSharp.Stats.Array.sampleWithReplacement``1(System.Random,``0[],System.Int32)">
<summary>
 Samples from an array of obj wit replacement (with putting back)
</summary>
</member>
<member name="M:FSharp.Stats.Array.median``3(``0[])">
<summary>
 Computes the sample median
</summary>
</member>
<member name="M:FSharp.Stats.Array.quickSelectInPlace``1(System.Int32,``0[])">
<summary>
 Finds the kth smallest element in an unordered array
 Works in place and can change the order of the elements in the input array
</summary>
</member>
<member name="M:FSharp.Stats.Array.quickSelect``1(System.Int32,``0[])">
<summary>
 Finds the kth smallest element in an unordered array
</summary>
</member>
<member name="M:FSharp.Stats.Array.partitionSortInPlace``1(System.Int32,System.Int32,``0[])">
<summary>
 Arranges the items between the left and right border, that all items left of the pivot element are smaller and bigger on the right.
 Function works in place and returns the index of the pivote element
</summary>
</member>
<member name="T:FSharp.Stats.Array">
<summary>
 Module to compute common statistical measure on array
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.ofReal(System.Double)">
<summary>
Creates a complex number of a real number (imaginary part 0)
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.tan(FSharp.Stats.Complex)">
<summary>
Evaluates the tangent of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sin(FSharp.Stats.Complex)">
<summary>
Evaluates the sine of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.cos(FSharp.Stats.Complex)">
<summary>
Evaluates the cosine of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sqrt(FSharp.Stats.Complex)">
<summary>
Evaluates square root of complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.log(FSharp.Stats.Complex)">
<summary>
Evaluates natural logarithm of complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.exp(FSharp.Stats.Complex)">
<summary>
Evaluates the exponent of the complex number to base e
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.pi">
<summary>
Pi as complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.iscale(System.Double,FSharp.Stats.Complex)">
<summary>
Rotates a complex number 90� counterclockwise and multiplies by scalar k
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.muls(FSharp.Stats.Complex,System.Double)">
<summary>
Multiplies complex number a by scalar b
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.smul(System.Double,FSharp.Stats.Complex)">
<summary>
Multiplies complex number b by scalar a
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.neg(FSharp.Stats.Complex)">
<summary>
Reverses sign of the real and the imaginary part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.div(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Divides complex number x by complex number y
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mul(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Multiplies two complex numbers
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.sub(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Substracts complex number b from complex number a
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.add(FSharp.Stats.Complex,FSharp.Stats.Complex)">
<summary>
Adds two complex numbers
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.abs(FSharp.Stats.Complex)">
<summary>
Evaluates the absolute value of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.imagPart(FSharp.Stats.Complex)">
<summary>
Gets the imaginary part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.realPart(FSharp.Stats.Complex)">
<summary>
Gets the real part of a complex number
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.phase(FSharp.Stats.Complex)">
<summary>
Evaluates the phase (or the angle) of the complex number in polar form
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.magnitude(FSharp.Stats.Complex)">
<summary>
Evalues magnitude of complex number
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.onei">
<summary>
Complex number with real part 0 and imaginary part 1
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.one">
<summary>
Complex number with real part 1 and imaginary part 0
</summary>
</member>
<member name="P:FSharp.Stats.ComplexModule.zero">
<summary>
Complex number with real part 0 and imaginary part 0
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.cis(System.Double)">
<summary>
Creates a complex number on the unit circle with b being the radius
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mkPolar(System.Double,System.Double)">
<summary>
Creates a complex number from its polar form where a is the radius and b is the angle
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.conjugate(FSharp.Stats.Complex)">
<summary>
Conjugates a complex number (reverses sign of imaginary part)
</summary>
</member>
<member name="M:FSharp.Stats.ComplexModule.mkRect(System.Double,System.Double)">
<summary>
Creates a complex number of a real part a and an imaginary part b
</summary>
</member>
<member name="T:FSharp.Stats.ComplexModule">
<summary>
Operations for complex number in cartesian form
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.kendall``2(``0[],``1[])">
<summary>
 Kendall Correlation Coefficient 
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.spearman``2(``0[],``1[])">
<summary>
 Spearman Correlation (with ranks)
</summary>
</member>
<member name="M:FSharp.Stats.Correlation.pearson``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Pearson correlation 
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Distribution`2">
<summary>
 Interface which every probability distribution must implement.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.uLSCV(System.Double[],Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Least squares cross-validation of bandwidth (unbiased)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.nrd0(System.Double[])">
<summary>
 Implements Silverman&apos;s ‘rule of thumb’ for choosing the bandwidth of a Gaussian kernel density estimator.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.freedmanDiaconis(System.Double[])">
<summary>
 Calcultes bandwidth based on the Freedman–Diaconis rule
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.scottNormal(System.Double[])">
<summary>
 Calcultes bandwidth according to Scott&apos;s normal reference rule
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.forHistogram(System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Simple bandwidth for histogram
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.fromBinNumber``3(``0,``1,``2)">
<summary>
 Calculates the bandwidth from min max and number of bins
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.riceRule(System.Double)">
<summary>
The Rice Rule is presented as a simple alternative to Sturges&apos;s rule.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.sturges(System.Double)">
<summary>
 Sturges&apos; formula is derived from a binomial distribution and implicitly assumes an approximately normal distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.sqrt(System.Double)">
<summary>
 Square-root choice
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Bandwidth.BinNumber.fromBandwidth(System.Double,System.Double,System.Double)">
<summary>
 Compute the number of bins from bandwidth
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Bandwidth.BinNumber">
<summary>
 Compute the number of bins for a histogram
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Bandwidth">
<summary>
 Bandwidth selectors 
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.F.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.F.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: (0., Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.F.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.F.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.F.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.F.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.F.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Continuous.F">
<summary>
 F-distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.StudentT.Variance(System.Double,System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.StudentT.Support(System.Double,System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: (Negative Infinity, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.StudentT.StandardDeviation(System.Double,System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.StudentT.Sample(System.Double,System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.StudentT.PDF(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.StudentT.Mean(System.Double,System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.StudentT.CDF(System.Double,System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Continuous.StudentT">
<summary>
 Student&apos;s T-distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Beta.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Beta.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0.0, 1.0).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Beta.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Beta.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Beta.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Beta.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Beta.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Continuous.Beta">
<summary>
 Beta distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Gamma.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Gamma.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Gamma.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Gamma.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Gamma.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Gamma.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Gamma.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Continuous.Gamma">
<summary>
 Gamma distribution
 Sampling implementation based on:
     &quot;A Simple Method for Generating Gamma Variables&quot; - Marsaglia &amp; Tsang
     ACM Transactions on Mathematical Software, Vol. 26, No. 3, September 2000, Pages 363-372.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Exponential.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Exponential.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Exponential.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Exponential.Sample(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Exponential.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Exponential.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Exponential.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Continuous.Exponential">
<summary>
 Exponential distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Normal.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Normal.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Normal.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Normal.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Normal.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Normal.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Normal.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Continuous.Normal">
<summary>
 Normal distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Uniform.Variance(System.Double,System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Uniform.Support(System.Double,System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Uniform.StandardDeviation(System.Double,System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Uniform.Sample(System.Double,System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Uniform.PDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Uniform.Mean(System.Double,System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.Uniform.CDF(System.Double,System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Continuous.Uniform">
<summary>
 Uniform distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.ChiSquared.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.ChiSquared.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.ChiSquared.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.ChiSquared.Sample(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.ChiSquared.PDFLn(System.Double,System.Double)">
<summary>
 Computes the logarithm of probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.ChiSquared.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.ChiSquared.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.ChiSquared.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Continuous.ChiSquared">
<summary>
 ChiSquared distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.f(System.Double,System.Double)">
<summary>
 Initializes a F-distribution         
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.studentT(System.Double,System.Double,System.Double)">
<summary>
 Initializes a Student&apos;s T-distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.beta(System.Double,System.Double)">
<summary>
 Initializes a Beta distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.gamma(System.Double,System.Double)">
<summary>
 Initializes a Gamma distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.exponential(System.Double)">
<summary>
 Initializes a Exponential distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.normal(System.Double,System.Double)">
<summary>
 Initializes a Normal distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.uniform(System.Double,System.Double)">
<summary>
 Initializes a uniform distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Continuous.chiSquared(System.Double)">
<summary>
 Initializes a ChiSquared distribution        
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Variance(System.Double,System.Int32)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Support(System.Double,System.Int32)">
<summary>
 Returns the support of the Binomial distribution: (0., n).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.StandardDeviation(System.Double,System.Int32)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.SampleUnchecked(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Sample(System.Double,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.PDF(System.Double,System.Int32,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.Mean(System.Double,System.Int32)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Binomial.CDF(System.Double,System.Int32,System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Binomial">
<summary>
Binomial distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Variance(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Support(System.Int32,System.Int32,System.Int32)">
<summary>
 Returns the support of the hypergeometric distribution: (0., Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.StandardDeviation(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.SampleUnchecked(System.Int32,System.Int32,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
 No parameter checking!
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Sample(System.Int32,System.Int32,System.Int32)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.PDF(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the probability density function at k, i.e. P(K = k)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.Mean(System.Int32,System.Int32,System.Int32)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Hypergeometric.CDF(System.Int32,System.Int32,System.Int32,System.Double)">
<summary>
 Computes the cumulative distribution function at x, i.e. P(X &lt;= x).
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Hypergeometric">
<summary>
Hypergeometric distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Variance(System.Double)">
<summary>
 Computes the variance.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Support(System.Double)">
<summary>
 Returns the support of the exponential distribution: [0, Positive Infinity).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.StandardDeviation(System.Double)">
<summary>
 Computes the standard deviation.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Sample``1(System.Double)">
<summary>
 Produces a random sample using the current random number generator (from GetSampleGenerator()).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.PDF(System.Double,System.Double)">
<summary>
 Computes the probability density function.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.Mean(System.Double)">
<summary>
 Computes the mean.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.Bernoulli.CDF(System.Double,System.Double)">
<summary>
 Computes the cumulative distribution function.
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete.Bernoulli">
<summary>
 Bernoulli distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.binomial(System.Double,System.Int32)">
<summary>
 Initializes a Binomial distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.hypergeometric(System.Int32,System.Int32,System.Int32)">
<summary>
 Initializes a hypergeometric distribution       
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Discrete.bernoulli(System.Double)">
<summary>
 Initializes a uniform distribution        
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Discrete">
<summary>
 Discrete probability distributions
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.create(System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Creates probability mass function    
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.exp(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Exponentiates the probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.log(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Log transforms the probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.var(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the variance of a PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.varAround(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the variance of a PMF around mu
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.mean(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Computes the mean of a PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.random(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Chooses a random element from this PMF
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizePDD(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF by the bandwidth to area equals 1.  (n/N)/Δx
 Probability Denisty Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizeBandwidth(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF by the bandwidth n/Δx
 Frequency Denisty Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizePercentage(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals 100 percent 
 Discrete Percentage Probability Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalize(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals 1. 
 Discrete Probability Distribution
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.normalizewith(System.Double,Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Normalizes this PMF so the sum of all probabilities equals fraction
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.probabilities(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Gets an unsorted sequence of probabilities
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.probabilityAt(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double},System.Double)">
<summary>
 Gets the probability associated with the value x
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getYValues(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns distinct values from pmf
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getXValues(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns distinct values from pmf
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.maxLike(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns the largest probability in the map.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.sum(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns the total of the probabilities in the map
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.getZip(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Double})">
<summary>
 Returns: tuple of (sorted value sequence, probability sequence)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Empirical.ofHistogram``1(Microsoft.FSharp.Collections.FSharpMap{``0,System.Int32})">
<summary>
 Creates Pmf of a Histogram (normalize by n)
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Empirical">
<summary>
 Represents a probability mass function (map from values to probabilities).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.isSubset(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32},Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Checks whether the values in this histogram A are a subset of the values in the histogram B
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.frequencies(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Gets an unsorted sequence of frequencies
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.frequencyAt(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32},System.Double)">
<summary>
 Gets the frequency associated with the value x
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.maxLike(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Gets the largest frequency in the map.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.sum(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Returns the total of the frequencies in the map
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.getZip(Microsoft.FSharp.Collections.FSharpMap{System.Double,System.Int32})">
<summary>
 Returns tuple of (sorted value sequence, frequence sequence)
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.create(System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Creates probability mass function (histogram)    
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.Frequency.createGeneric``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Given the list [a,b,a,c,b,b], produce a map {a:2, b:3, c:1} which contains the count of each unique item in the list
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.Frequency">
<summary>
 Represents a histogram (map from values to integer frequencies).
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.mapInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0[])">
<summary>
 Applying the given function to each of the elements of the array and returns the value in place.
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.cosine(System.Double,System.Double)">
<summary>
 Cosine kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.biweight(System.Double,System.Double)">
<summary>
 Biweight kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.epanechnikov(System.Double,System.Double)">
<summary>
 Epanechnikov kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.triangular(System.Double,System.Double)">
<summary>
 Triangular kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.rectangular(System.Double,System.Double)">
<summary>
 Rectangular kernel
</summary>
</member>
<member name="M:FSharp.Stats.Distributions.KernelDensity.Kernel.gaussian(System.Double,System.Double)">
<summary>
 Gausian kernel
</summary>
</member>
<member name="T:FSharp.Stats.Distributions.KernelDensity">
<summary>
 Module to perform Kernel density estimation
</summary>
</member>
<member name="T:FSharp.Stats.DoubleImpl">
<summary>
 Implementations of operations specific to floating point types
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Hermite.initEvalAtWithLinearInterpol(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.Hermite.leftSegmentIdx``1(``0[],``0)">

</member>
<member name="P:FSharp.Stats.Fitting.Regression.SumOfSquares.Count">
<summary>
 Count N
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.Regression.SumOfSquares.Total">
<summary>
 Total sum of squares (SST - total)
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.Regression.SumOfSquares.Error">
<summary>
 Error sum of squares (SSE - unexplained)
</summary>
</member>
<member name="P:FSharp.Stats.Fitting.Regression.SumOfSquares.Regression">
<summary>
 Regression sum of squares (SSR - explained) 
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.Regression.SumOfSquares">
<summary>
 Three sum of squares 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.calculateANOVA(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 explained = total - unexplained
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.calculateSST(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates SST: sum of squares total
 also: total sum of squares
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.calculateSSE(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates SSE: sum of squares of errors
 also: unexplained sum of squares    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.getResiduals(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Calculates the residuals
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.calcBIC(System.Double,System.Double,System.Double)">
<summary>
 Calculates Bayesian information criterion (BIC) which is a measure of the relative quality of a regression model for a given set of data
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.calcAIC(System.Double,System.Double,System.Double)">
<summary>
 Calculates Akaike information criterion (AIC) which is a measure of the relative quality of a regression model for a given set of data    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.calulcateDeterminationFromValue(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Gets the coefficient of determination, as known as the R-Squared (R�)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.stDevIntercept(FSharp.Stats.Fitting.Regression.SumOfSquares)">
<summary>
 Standard deviation of intercept (alpha)
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.stDevSlope(FSharp.Stats.Fitting.Regression.SumOfSquares)">
<summary>
 Standard deviation of slope (beta)    
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.stDevY(FSharp.Stats.Fitting.Regression.SumOfSquares)">
<summary>
 Standard deviation of y(x) 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.calulcateSumOfSquares(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.Regression.Polynomial.fit(System.Int32,FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.Polynomial.coefficient(System.Int32,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Caclualtes the coefficients for polynomial regression
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.Regression.Polynomial">
<summary>
 Simple polynomial regression
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.Linear.fit(FSharp.Stats.Vector{System.Double},System.Double)">
<summary>
 Fit to x
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.Linear.coefficient(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Caclualtes the coefficients for linear regression
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.Linear.coefficientOfMatrix(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Caclualtes the coefficients for linear regression
 in the form of [|intercept; slope;|]
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.Linear.RTO.calculateANOVA(System.Double,FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">

</member>
<member name="M:FSharp.Stats.Fitting.Regression.Linear.RTO.fit(System.Double,System.Double)">
<summary>
 Fit to x
 coefficient is beta only
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.Linear.RTO.fitFunc(System.Double,System.Double)">
<summary>
 Returns the regression function
 coefficient is beta only
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.Linear.RTO.coefficient(Microsoft.FSharp.Collections.FSharpList{System.Double},Microsoft.FSharp.Collections.FSharpList{System.Double})">
<summary>
 Caclualtes the coefficients for linear regression through the origin 
</summary>
</member>
<member name="M:FSharp.Stats.Fitting.Regression.Linear.RTO.coefficientOfVector(FSharp.Stats.Vector{System.Double},FSharp.Stats.Vector{System.Double})">
<summary>
 Caclualtes the coefficients for linear regression through the origin 
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.Regression.Linear.RTO">
<summary>
 Regression through the origin (y : x -&gt; bx)
</summary>
</member>
<member name="T:FSharp.Stats.Fitting.Regression.Linear">
<summary>
 Simple linear regression y : x -&gt; a + bx
</summary>
</member>
<member name="M:FSharp.Stats.GenericImpl.cptMulDenseMatrixGU``1(FSharp.Stats.DenseMatrix{``0},FSharp.Stats.DenseMatrix{``0})">
<summary>
Point-wise multiplication 
</summary>
</member>
<member name="M:FSharp.Stats.GenericImpl.initSparseMatrixGU``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{FSharp.Stats.INumeric{``0}},System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,``0}})">
<summary>
 Create a matrix from a sparse sequence 
</summary>
</member>
<member name="T:FSharp.Stats.GenericImpl">
<summary>
 Implementations of operations that will work for any type
</summary>
</member>
<member name="M:FSharp.Stats.Integration.Differentiation.differentiateThreePoint(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Three-Point Differentiation Helper.
 xValues Sample Points t.
 yValues Sample Values x(t)
 idxT Index of the point of the differentiation.&lt;/param&gt;
 idx0 Index of the first sample.&lt;/param&gt;
 idx1 Index of the second sample.&lt;/param&gt;
 idx2 Index of the third sample.&lt;/param&gt;
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.Approximation.approx(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},System.Double})">
<summary>
 Return a sequence of points which linearly interpolate given data points, or a function performing the linear interpolation.
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.Approximation.regularizeValues(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.Double},System.Double})">
<summary>
 Regularize (like R! regularize.values) used in approx
 1. pairs x -y values 
 2. filters nan on both sides and sortby x
 3. handels ties by given function
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.C3">
<summary>
 Third order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.C2">
<summary>
 Second order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.C1">
<summary>
 First order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.C0">
<summary>
 Zero order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients.XValues">
<summary>
 sample points (N+1), sorted ascending
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.definiteIntegral(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.integrate(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.computeIndefiniteIntegral(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.secondDerivative(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.firstDerivative(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.interpolateAtX(FSharp.Stats.Interpolation.CubicSpline.SplineCoefficients,System.Double)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.akimaCoefficients(System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.leftSegmentIdx``1(``0[],``0)">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.interpolateHermiteSorted(System.Double[],System.Double[],System.Double[])">

</member>
<member name="M:FSharp.Stats.Interpolation.CubicSpline.createSplineCoefficients(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">

</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.C1">
<summary>
 First order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.C0">
<summary>
 Zero order spline coefficients (N)
</summary>
</member>
<member name="P:FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef.XValues">
<summary>
 sample points (N+1), sorted ascending
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.differentiate(FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef,System.Double)">
<summary>
 Differentiate at point x
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.interpolate(FSharp.Stats.Interpolation.LinearSpline.LinearSplineCoef,System.Double)">
<summary>
 Interpolate at point x
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolate(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from unsorted x,y data     
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolateInplace(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from unsorted x,y data 
 Works in place
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.initInterpolateSorted(System.Double[],System.Double[])">
<summary>
 Returns the linear spline interpolation coefficients from sorted x,y data
</summary>
</member>
<member name="M:FSharp.Stats.Interpolation.LinearSpline.createLinearSplineCoef(System.Double[],System.Double[],System.Double[])">

</member>
<member name="T:FSharp.Stats.Intervals.Interval`1">
<summary>
 Closed interval [Start,End]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.liesInInterval``1(``0,FSharp.Stats.Intervals.Interval{``0})">
<summary>
   Does the given value lie in the interval or not.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getValueAt``2(System.Double,FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Get the value at a given percentage within (0.0 - 1.0) or outside (&lt; 0.0, &gt; 1.0) of the interval. Rounding to nearest neighbour occurs when needed.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.intersect``1(FSharp.Stats.Intervals.Interval{``0},FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the intersection of this interval with another.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.isIntersection``1(FSharp.Stats.Intervals.Interval{``0},FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Checking for intersection of both intervals
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.subtract(FSharp.Stats.Intervals.Interval{System.Int32},FSharp.Stats.Intervals.Interval{System.Int32})">
<summary>
 Subtract a given interval from the other interval.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.add(FSharp.Stats.Intervals.Interval{System.Int32},FSharp.Stats.Intervals.Interval{System.Int32})">
<summary>
 Add two given intervals.
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.toString``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the interval as a string
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.trySize``2(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns the size of an closed interval
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getEnd``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns max/end value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.getStart``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns min/start value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.values``1(FSharp.Stats.Intervals.Interval{``0})">
<summary>
 Returns min and max value of Interval [min,max]
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.ofSize(System.Int32,System.Int32)">
<summary>
 Creates closed interval [min,max] by given start and size
</summary>
</member>
<member name="M:FSharp.Stats.Intervals.create``1(``0,``0)">
<summary>
 Creates closed interval [min,max] by given min and max
</summary>
</member>
<member name="T:FSharp.Stats.LapackMKLStubs">
<summary>
 Warning:
 IMPORTANT WARNING NOTICE:
 INTEL MATH KERNEL LIBRARY 9.1 FOR WINDOWS IS THIRD PARTY TECHNOLOGY.
 IT IS CLEARED ONLY FOR USE BY A SPECIFIC MSR RESEARCH TEAM.
 DO NOT USE IT UNTIL YOU HAVE CLEARED ITS USE FOR YOUR PROJECT WITH YOUR LEGAL CONTACT.
 
 The following stubs bind directly to Intel MKL functionality.
 You should not use them without:
 a) Intel MKL developer licenses.
 b) Seeking local legal approval.
</summary>
</member>
<member name="M:FSharp.Stats.LinearAlgebraMKL.dgesdd_(FSharp.Stats.Matrix{System.Double})">
<summary>
Singular Value Decomposition Divide- Conquer
</summary>
</member>
<member name="M:FSharp.Stats.LinearAlgebraMKL.dgemm_(FSharp.Stats.Matrix{System.Double},FSharp.Stats.Matrix{System.Double})">
<summary>
Matrix-Matrix Multiplication
</summary>
</member>
<member name="M:FSharp.Stats.List.median``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Calculate the median of a list of items.
 The result is a tuple of two items whose mean is the median.
</summary>
</member>
<member name="T:FSharp.Stats.List">
<summary>
 Module to compute common statistical measure on list
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.meanColumnWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the Column wise mean of a Matrix 
</summary>
</member>
<member name="M:FSharp.Stats.MatrixModule.meanRowWise(FSharp.Stats.Matrix{System.Double})">
<summary>
 Computes the row wise mean of a Matrix 
</summary>
</member>
<member name="M:FSharp.Stats.Ops.signum(System.Double,System.Double)">
<summary>
 Signum function, assigns a positive sign to a with respect to the signing of b. 
</summary>
</member>
<member name="M:FSharp.Stats.Ops.round(System.Int32,System.Double)">
<summary>
 Rounds a double-precision floating-point value to a specified number of fractional digits.  
</summary>
</member>
<member name="M:FSharp.Stats.Ops.arsinh(System.Double)">

</member>
<member name="M:FSharp.Stats.Ops.square``2(``0)">
<summary>
 Returns x squared (x^2)
</summary>
</member>
<member name="M:FSharp.Stats.Ops.revLog2(System.Double)">
<summary>
 Returns the reverted log2 (2^x)
</summary>
</member>
<member name="M:FSharp.Stats.Ops.isInf(System.Double)">
<summary>
 Returs true if x is Float infinity
</summary>
</member>
<member name="M:FSharp.Stats.Ops.isNan(System.Double)">
<summary>
 Returs true if x is Float NaN
</summary>
</member>
<member name="M:FSharp.Stats.Ops.log10(System.Double)">
<summary>
 Returns the logarithm for x in base 10.
</summary>
</member>
<member name="M:FSharp.Stats.Ops.log2(System.Double)">
<summary>
 Returns the logarithm for x in base 2.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.NaN">
<summary>
 Float NaN.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.inf">
<summary>
 Float infinity.
</summary>
</member>
<member name="P:FSharp.Stats.Ops.pi">
<summary>
 The constant pi = 3.141596...
</summary>
</member>
<member name="T:FSharp.Stats.Ops">
<summary>
 Operations module (automatically opened)
</summary>
</member>
<member name="M:FSharp.Stats.Optimization.Bisection.tryFindRoot(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double,System.Double,System.Int32)">
<summary>
Finds the value in an interval for which a given function returns a value at least as close to 0 as the accuracy 
</summary>
</member>
<member name="M:FSharp.Stats.Precision.almostEqualNorm(System.Double,System.Double)">
<summary>
 Compares two float values and determines if they differ by no more than 10.*(2.**(-52.).
</summary>
</member>
<member name="M:FSharp.Stats.Precision.almostEqualNormRelative(System.Double,System.Double,System.Double)">
<summary>
 Compares two float values and determines if they differ by no more than specified by the maximum error.
</summary>
</member>
<member name="T:FSharp.Stats.Precision">
<summary>
 Module to estimate different quantile measures
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.computePercentiles``1(Microsoft.FSharp.Core.FSharpFunc{System.Double[],``0},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Computes percentiles
 percentiles: Each percentile must be between 0.0 and 1.0 (inclusive)
 CalcMethod should be ofSorted array
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.interQuantileRange``1(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{``0[],System.Double}},``0[])">
<summary>
 Computes the interquartile range (IQR)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.normal(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.mode(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
 R! default
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.nist(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.hazen(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.california(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.nearest(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.empiricalInvCdfAverage(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.empiricalInvCdf(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.compute(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array.
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.normal(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.mode(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.nist(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.hazen(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.california(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.nearest(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.empiricalInvCdfAverage(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.empiricalInvCdf(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.OfSorted.compute(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="T:FSharp.Stats.Quantile.OfSorted">
<summary>
 ! Input needs to be sorted
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.normalInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.modeInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.nistInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.hazenInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.californiaInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.nearestInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.empiricalInvCdfAverageInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.empiricalInvCdfInPLace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
</summary>
</member>
<member name="M:FSharp.Stats.Quantile.InPlace.computeInplace(System.Double,System.Double[])">
<summary>
 Estimates the q-th quantile from the unsorted data array. (in place)
 Approximately median-unbiased regardless of the sample distribution.
</summary>
</member>
<member name="T:FSharp.Stats.Quantile.InPlace">
<summary>
 ! Works inplace and can thus causes the data array to be reordered
</summary>
</member>
<member name="T:FSharp.Stats.Quantile">
<summary>
 Module to estimate different quantile measures
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandBasic.#ctor(System.Int32)">
<summary>
 If n is negative, the random number generator seed is based on system time, if it is zero or positive it will
 use n as the seed.
</summary>
</member>
<member name="M:FSharp.Stats.Random.RandBasic.#ctor">
<summary>
 Constructs the default random number generator with seed 17.
</summary>
</member>
<member name="T:FSharp.Stats.Random.RandBasic">
<summary>
 A standard implementation of a uniform random source using System.Random()
</summary>
</member>
<member name="T:FSharp.Stats.Random.IRandom">
<summary>
 Interface that every uniform random number generator must implement.
</summary>
</member>
<member name="M:FSharp.Stats.Random.GetSampleGenerator">
<summary>
 Returns the random number generator used for sampling.
</summary>
</member>
<member name="M:FSharp.Stats.Random.SetSampleGenerator(FSharp.Stats.Random.IRandom)">
<summary>
 Sets the random number generator used for sampling.
</summary>
</member>
<member name="P:FSharp.Stats.Random.rndgen">
<summary>
 The uniform random source used for sampling functions.
</summary>
</member>
<member name="T:FSharp.Stats.Random">
<summary>
 Uniform random number generators
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankAverage``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their mean
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankMax``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their maximum  
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankMin``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Ties are replaced by their minimum  
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rankFirst``1(``0[])">
<summary>
 Ranks each entry of the given unsorted data array.
 Permutation with increasing values at each index of ties.
</summary>
</member>
<member name="M:FSharp.Stats.Rank.rank``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0},``1[])">
<summary>
 Ranks each entry of the given unsorted data array. Use &apos;breakTies function to break ties
</summary>
</member>
<member name="T:FSharp.Stats.Rank">
<summary>
 Module to Calculate the rank. The rank of a number is its size relative to other values in a sequence
</summary>
</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.tryFindRoot(Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">
<summary>
 Convergence is reached, return root
 accuracy is not sufficient to reach a root 
</summary>
</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.tryFindRootWith(System.Double,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double},System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.updateBounds``2(Microsoft.FSharp.Core.FSharpFunc{System.Double,``0},System.Double,System.Double,``1,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.attemptInverseQuadraticInterpolation``1(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,``0,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.acceptBisection``2(``0,``1)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.acceptInterPolation``1(``0,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.checkConvergence(System.Double,System.Double,System.Double,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.Rootfinding.Brent.adjustBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">

</member>
<member name="M:FSharp.Stats.RunningStats.stDevPopulation``2(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.stDev``2(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.var``1(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.RunningStats.varPopulation``1(FSharp.Stats.RunningStats.RunningStats{``0})">

</member>
<member name="M:FSharp.Stats.Seq.stats``3(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns SummeryStats of deq with N, mean, sum-of-squares, minimum and maximum
</summary>
</member>
<member name="M:FSharp.Stats.Seq.cvPopulationBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of the population (population standard deviation)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of the population</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cvPopulation``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of the population (population standard deviation)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of the population</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cvBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of a sample (Bessel's correction by N-1)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.cv``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the Coefficient of Variation of a sample (Bessel's correction by N-1)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>Coefficient of Variation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.stDevPopulationBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population standard deviation (denominator = N)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population standard deviation (denominator = N)</returns>     
</member>
<member name="M:FSharp.Stats.Seq.stDevPopulation``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population standard deviation (denominator = N)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population standard deviation (denominator = N)</returns>     
</member>
<member name="M:FSharp.Stats.Seq.stDevBy``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample standard deviation
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>standard deviation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.stDev``4(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample standard deviation
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>standard deviation of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varPopulationBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes variance of the given values (denominator N)
 </summary>
    
 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population variance estimator (denominator N)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varPopulation``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes variance of the given values (denominator N)
 </summary>
    
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population variance estimator (denominator N)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.varBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample variance (Bessel's correction by N-1)
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>variance of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.var``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the sample variance (Bessel's correction by N-1)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>variance of a sample (Bessel's correction by N-1)</returns> 
</member>
<member name="M:FSharp.Stats.Seq.median``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sample Median
</summary>
</member>
<member name="M:FSharp.Stats.Seq.meanTruncatedBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Double,System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the truncated (trimmed) mean
 </summary>

 <param name="items">The input sequence.</param>
 <param name="f">A function applied to transform each element of the sequence.</param>    
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>truncated (trimmed) mean</returns>  
</member>
<member name="M:FSharp.Stats.Seq.meanTruncated``2(System.Double,System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the truncated (trimmed) mean
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>truncated (trimmed) mean</returns>  
</member>
<member name="M:FSharp.Stats.Seq.meanGeometricBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes gemetric mean
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>gemetric mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanGeometric``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes gemetric mean
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>gemetric mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanHarmonicBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes harmonic mean
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>harmonic mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanHarmonic``3(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes harmonic mean
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>harmonic mean</returns>   
</member>
<member name="M:FSharp.Stats.Seq.meanBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population mean (Normalized by N)s
 </summary>

 <param name="f">A function applied to transform each element of the sequence.</param>
 <param name="items">The input sequence.</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>population mean (Normalized by N)</returns>   
</member>
<member name="M:FSharp.Stats.Seq.mean``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the population mean (Normalized by N)
 </summary>

 <param name="items">The input sequence.</param>
 <remarks>Returns default value if data is empty or if any entry is NaN.</remarks>
 <returns>population mean (Normalized by N)</returns>   
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevPopulation``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled population standard deviation of the given values (Bessel's correction by N-1)
 </summary>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevPopulationOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled population standard deviation of the given values (Bessel's correction by N-1)
 </summary>

 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDev``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled standard deviation of the given values.
 </summary>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledStDevOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled standard deviation of the given values
 </summary>

 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>       
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarPopulation``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled population variance of the given values (Bessel's correction by N-1)
 </summary>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarPopulationOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled population variance of the given values (Bessel's correction by N-1)
 </summary>
 
 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVar``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
   Computes the pooled variance of the given values
 </summary>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.pooledVarOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes the pooled variance of the given values
 </summary>
 
 <param name="sizes">The number of samples</param>
 <param name="variances">The population variances for each samples.</param>
</member>
<member name="M:FSharp.Stats.Seq.UtilityFunctions.sumOfSquares(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
   Computes sum of squares
 </summary>

 <param name="items">seq of float</param>
 <remarks>Returns NaN if data is empty or if any entry is NaN.</remarks>
 <returns>sum of squares</returns> 
</member>
<member name="T:FSharp.Stats.Seq.UtilityFunctions">
<summary>
 A module which implements helper functions to provide special statistical measures
</summary>
</member>
<member name="T:FSharp.Stats.Seq">
<summary>
 Module to compute common statistical measure
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.baselineAls(System.Int32,System.Int32,System.Double,System.Double[])">
<summary>
 Asymmetric Least Squares Smoothing by P. Eilers and H. Boelens in 2005
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.diff(System.Int32,System.Double[0:,0:])">
<summary>
 Calculate the n-th order discrete difference along given axis.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Baseline.diag``1(System.Int32,``0)">
<summary>
 Creates a diagonal 2-D array with the given order and set all diagonal values to x
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.inverseSymmetricScalingInPlace(System.Double[])">
<summary>
 Universal; Symmetric scaling and common exponent (used in Maple) Default
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.inverseAsymmetricScalingInPlace(System.Double[])">
<summary>
 Only scale by 1/N in the inverse direction; No scaling in forward direction.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.symmetricScalingInPlace(System.Double[])">
<summary>
 Universal; Symmetric scaling and common exponent (used in Maple) Default InverseExponent
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.asymmetricScalingInPlace(System.Double[])">
<summary>
 No scaling in forward direction.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.bluestein(FSharp.Stats.Complex[])">
<summary>
 Bluestein�s convolution algorith
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.bitrev``1(``0[])">
<summary>
 Reorder the elements of the input array in lexicographic order by the bits of their indices
</summary>
</member>
<member name="M:FSharp.Stats.Signal.FFT.mapInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0[])">
<summary>
 Applying the given function to each of the elements of the array and returns the value in place.
</summary>
</member>
<member name="T:FSharp.Stats.Signal.FFT">
<summary>
 FFT analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa.
</summary>
</member>
<member name="M:FSharp.Stats.Signal.Filtering.savitzky_golay``3(System.Int32,System.Int32,``0,``1,System.Double[])">
<summary>
 Smooth (and optionally differentiate) data with a Savitzky-Golay filter.
 The Savitzky-Golay filter is a type of low-pass filter and removes high frequency noise from data.
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.lowerIncomplete(System.Double,System.Double,System.Double)">
<summary>
 Returns the regularized lower incomplete beta function
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.beta(System.Double,System.Double)">
<summary>
 Computes the beta function.
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Beta.betaLn(System.Double,System.Double)">
<summary>
 Computes the natural logarithm of the beta function.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Beta">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Binomial">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Errorfunction.Erfc(System.Double)">
<summary>
 Computes the complement of the error function. Note that this implementation has only been verified to have a relative error of around 1e-4.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Errorfunction">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Factorial.factorialLn(System.Int32)">
<summary>
 Computes the natural logarithm of the factorial function.
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Factorial.factorial(System.Int32)">
<summary>
 The factorial functions takes an int x and computes x!. This function will not overflow
 the floating point format as long as x is at most 170.
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Factorial">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.upperIncomplete(System.Double,System.Double)">
<summary>
 Returns the incomplete gamma function Q(a,X) = 1 - P(a,X) (regularized gamma) 
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.lowerIncomplete(System.Double,System.Double)">
<summary>
 Returns the incomplete gamma function P(a,X) (regularized gamma) 
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.gammaLn(System.Double)">
<summary>
 Computes the log gamma function using the Lanczos Coefficients described in Numerical Recipes (Press et al)
</summary>
</member>
<member name="M:FSharp.Stats.SpecialFunctions.Gamma.gamma(System.Double)">
<summary>
 Computes the gamma function using the Lanczos Coefficients described in Numerical Recipes (Press et al) 
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Gamma">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="T:FSharp.Stats.SpecialFunctions.Logistic">
<summary>
 Special mathematical functions
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.mergedNonZeroEntriesM``1(FSharp.Stats.Matrix{``0},FSharp.Stats.Matrix{``0})">
<summary>
 Non-zero entries from two sequences
</summary>
</member>
<member name="M:FSharp.Stats.SpecializedGenericImpl.mergeSorted``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Merge two sorted sequences
</summary>
</member>
<member name="T:FSharp.Stats.SpecializedGenericImpl">
<summary>
 Generic operations that, when used on floating point types, use the specialized versions in DoubleImpl
</summary>
</member>
<member name="M:FSharp.Stats.SummeryStats.var``3(FSharp.Stats.SummeryStats.SummeryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummeryStats.varPopulation``2(FSharp.Stats.SummeryStats.SummeryStats{``0})">

</member>
<member name="M:FSharp.Stats.SummeryStats.mean``1(FSharp.Stats.SummeryStats.SummeryStats{``0})">

</member>
<member name="T:FSharp.Stats.SummeryStats">
<summary>
 Module to compute common statistical measure on 
</summary>
</member>
<member name="M:FSharp.Stats.Testing.Anova.oneWayAnova``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calculates one-way analysis of variance (one-way ANOVA) which is a technique used to compare means of two or more samples (using the F distribution)
 The ANOVA tests the null hypothesis that samples in two or more groups are drawn from populations with the same mean values.
</summary>
</member>
<member name="M:FSharp.Stats.Testing.Bartlett.compute``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Bartlett&apos;s test for equality of variances
 Tests the null hypothesis that all group variances are equal
</summary>
</member>
<member name="M:FSharp.Stats.Testing.ChiSquareTest.compute(System.Int32,System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
<summary>
 Computes the Chi-Square test
</summary>
</member>
<member name="T:FSharp.Stats.Testing.ChiSquareTest">
 <summary>
   Two-Sample (Goodness-of-fit) Chi-Square Test (Upper Tail)
 </summary>
 
 <remarks>
 <para>
   A chi-square test (also chi-squared or χ2  test) is any statistical
   hypothesis test in which the sampling distribution of the test statistic
   is a <see cref="ChiSquareDistribution">chi-square distribution</see> when
   the null hypothesis is true, or any in which this is asymptotically true,
   meaning that the sampling distribution (if the null hypothesis is true) 
   can be made to approximate a chi-square distribution as closely as desired
   by making the sample size large enough.</para>
 <para>
   The chi-square test is used whenever one would like to test whether the
   actual data differs from a random distribution. </para>
   
 <para>
   References:
   <list type="bullet">
     <item><description><a href="http://en.wikipedia.org/wiki/Chi-square_test">
        Wikipedia, The Free Encyclopedia. Chi-Square Test. Available on:
        http://en.wikipedia.org/wiki/Chi-square_test </a></description></item>
   
     <item><description><a href="http://www2.lv.psu.edu/jxm57/irp/chisquar.html">
        J. S. McLaughlin. Chi-Square Test. Available on:
        http://www2.lv.psu.edu/jxm57/irp/chisquar.html </a></description></item>
   </list></para>
 </remarks>
 
</member>
<member name="M:FSharp.Stats.Testing.PvalueAdjust.Benjamini_Hochberg``1(System.Collections.Generic.IEnumerable{System.Tuple{``0,System.Double}})">
<summary>
 Benjamini-Hochberg Correction (BH)
</summary>
</member>
<member name="M:FSharp.Stats.Testing.TTest.noAssumtion(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
 Equal or unequal sample sizes, assume nothing about variance.
 input: (mean1,variance1,N1) (mean2,variance2,N3)
</summary>
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.ChiSquareStatistics">
 <summary>
   Computes the Chi-Square test statistics for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="Statistic">The test statistic.</param>
 <param name="DegreesOfFreedom">The degrees of freedom for the numerator.</param>    
 <param name="PValueLeft">One Tailed/Sided.</param>
 <param name="PValueRight"> One Tailed/Sided.</param>   
 <param name="PValue">Two Tailed/Sided.</param>   
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.FTestStatistics">
 <summary>
   Creates a new F-Test for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="statistic">The test statistic.</param>
 <param name="d1">The degrees of freedom for the numerator.</param>
 <param name="d2">The degrees of freedom for the denominator.</param>
</member>
<member name="T:FSharp.Stats.Testing.TestStatistics.TTestStatistics">
 <summary>
   Creates a new T-Test for a given statistic
   with given degrees of freedom.
 </summary>
 
 <param name="Statistic">The test statistic.</param>
 <param name="DegreesOfFreedom">The degrees of freedom for the numerator.</param>    
 <param name="PValueLeft">One Tailed/Sided.</param>
 <param name="PValueRight"> One Tailed/Sided.</param>   
 <param name="PValue">Two Tailed/Sided.</param>   
</member>
<member name="M:FSharp.Stats.VectorModule.stats``3(FSharp.Stats.Vector{``0})">
<summary>
 Returns SummeryStats of vector with N, mean, sum-of-squares, minimum and maximum
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.median``3(FSharp.Stats.Vector{``0})">
<summary>
 Computes the sample median
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.mean``2(FSharp.Stats.Vector{``0})">
<summary>
 Computes the population mean (Normalized by N)            
</summary>
</member>
<member name="M:FSharp.Stats.VectorModule.interval``1(FSharp.Stats.Vector{``0})">

</member>
<member name="M:FSharp.Stats.VectorModule.raw``1(FSharp.Stats.Vector{``0})">
<summary>
 Returns the raw data array without copy
</summary>
</member>
</members>
</doc>
